■ 9-1. 次の項目について〇か×で答えてください。
    1. 次のコードの記述によって、どのコンピュータでも同じように出力される。

#include <iostream>
using namespace std;

int main() {
    int a = 5;
    cout << "変数aのアドレスは" << &a << "です。\n";
    return 0;
}
    　×
    2. ポインタを宣言した後、そのポインタに別の文で変数のアドレスを代入することができる。
    　〇
    3. 参照を宣言したあと、その参照に別の文で変数を代入することができる。
    　×

■10-1. 次の項目について〇か×で答えてください。
    1. グローバル変数とローカル変数には、同じ識別子を使うことができる。
    　〇
    2. 別の関数内で宣言された2つのローカル変数には、同じ識別子を使うことができる。
    　〇
    3. 無指定のローカル変数は静的寿命をもつ。
    　×
    4. ローカル変数はそれを宣言した関数外の関数から利用することができる。
    　×
    5. 無指定のグローバル変数はどの関数からも利用することができる。
    　〇

■10-2. 次のコードの誤りを訂正してください。
#include <iostream>
using namespace std;

int main() {
    int* pA;
    pA = new int;
    *pA = 10;

    return 0;
}

delete演算子でヒープメモリを解放していない。

■11-1. 次の項目に〇か×で答えてください。
    1. クラス宣言内において、アクセス指定子を省略したメンバは、publicメンバとなる。
    　×
    2. クラス宣言内において、メンバ関数を定義すると、インライン関数となる。
    　〇
    3. データメンバをpublicとして指定することはできない。
    　×
    4. publicメンバはクラスの外側からアクセスすることができる。
    　〇
    5. privateメンバはクラスの外側からアクセスすることができない。
    　〇

■13-1. 次の項目について〇か×で答えてください。
    1. クラスには必ず1つ以上のコンストラクタを記述する必要がある。
    　×
    2. コンストラクタは戻り値をもたない。
    　〇
    3. コンストラクタは引数をとらない。
    　×

■13-2. 次の項目について〇か×で答えてください。
    1. 静的データメンバには、オブジェクトが作成されていないとアクセスできない。
    　×
    2. 静的でない通常のデータメンバには、オブジェクトが作成されていなくてもアクセスできる。
    　×
    3. 静的メンバ関数内では、静的でない通常のデータメンバにアクセスできる。
    　×

■14-1. 次の項目について〇か×で答えてください。
    1. 基本クラスから派生できるクラスの数は決まっている。
    　×
    2. 派生クラスからさらにクラスを派生させることを多重継承という。
    　×
    3. 派生クラスでは、基本クラスと同じ名前のメンバ関数を持つことができる。
    　〇

■14-2. 次の項目について〇か×で答えてください。
    1. 抽象クラスへのポインタは宣言することができない。
    　×
    2. 抽象クラスのオブジェクトは作成することができない。
    　〇
    3. 派生クラスのオブジェクトのアドレスは、基本クラスのポインタに代入できる。
    　〇

■14-3. 次のコードの誤りを指摘してください。

//Base1クラスの宣言
class Base1 {
    protected:
        int bs1;
    public:
        Base1(int b1=0){bs1=b1;}
        void showBs();
};

//Base2クラスの宣言
class Base2 {
    protected:
        int bs2;
    public:
        Base2(int b2=0){bs2=b2;}
        void showBs();
};

//Base1クラスメンバ関数の定義
void Base1::showBs(){
    cout << "bs1は" << bs1 << "です。\n";
}

//Base2クラスメンバ関数の定義
void Base2::showBs(){
    cout << "bs2は" << bs2 << "です。\n";
}

//Derivedクラスの定義
class Derived() : public Base1, public Base2 {
    protected:
        int dr;
    public:
        Derived(int d=0){dr=d;}
        void showDr();
}

//Derivedクラスメンバ関数の定義
void Derived()::showDr() {
    cout << "drは" << dr << "です。\n";
}

int main() {
    Derived drv;
    drv.showBs();
    drv.showDr();

    return 0;
}

Base1、Base2のどちらが持つshowBs()を呼んでいるのかが判断できない。
(showBs()の呼び出しが曖昧である)

■15-1. 次の項目について〇か×で答えてください。
    1. 演算子は、メンバ関数としてもフレンド関数としても定義できる場合がある。
    　〇
    2. すべての演算子をオーバーロードできるわけではない。
    　〇
    3. 単項演算子をオーバーロードして、2項演算子とすることができる。
    　×

■15-2. 次の項目について〇か×で答えてください。
    1. クラス宣言内には、複数のデストラクタ宣言を記述することができる。
    　×
    2. デストラクタは戻り値と引数を持たない。
    　〇
    3. オブジェクトにほかのオブジェクトの値を代入する際には、コピーコンストラクタが呼び出される。
    　×